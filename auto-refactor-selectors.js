import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Define the directories where your test files are located
const TEST_FILE_DIRS = ['src/step-definitions', 'src/features'];

// --- Main Logic ---

/**
 * Recursively finds all files in a given directory.
 * @param {string} dir - The directory to search.
 * @returns {string[]} - An array of full file paths.
 */
function getAllFiles(dir) {
    let results = [];
    if (!fs.existsSync(dir)) {
        console.warn(`⚠️ Directory not found, skipping: ${dir}`);
        return [];
    }
    const list = fs.readdirSync(dir);
    list.forEach(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        if (stat && stat.isDirectory()) {
            results = results.concat(getAllFiles(filePath));
        } else {
            results.push(filePath);
        }
    });
    return results;
}

function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function refactorFile(filePath, mapping) {
    // Allow refactoring in feature files, and JavaScript/TypeScript step definitions/page objects.
    if (!/\.(feature|js|ts)$/.test(filePath)) {
        return false;
    }

    let content = fs.readFileSync(filePath, 'utf8');
    let changed = false;

    for (const oldSelectorAttr of Object.keys(mapping)) {
        const newSelectorAttr = mapping[oldSelectorAttr];

        if (!newSelectorAttr || oldSelectorAttr === newSelectorAttr) continue;

        // This script is specifically designed to handle data-testid attributes.
        // It extracts the value from the attribute and replaces that value in test files.
        const oldMatch = oldSelectorAttr.match(/\[data-testid="(.+?)"\]/);
        const newMatch = newSelectorAttr.match(/\[data-testid="(.+?)"\]/);

        if (!oldMatch || !newMatch) continue;

        const oldSelectorValue = oldMatch[1];
        const newSelectorValue = newMatch[1];

        // This regex is more robust, handling both single and double quotes.
        const regex = new RegExp(`(["'])${escapeRegex(oldSelectorValue)}\\1`, 'g');
        const newContent = content.replace(regex, `$1${newSelectorValue}$1`);

        if (newContent !== content) {
            content = newContent;
            console.log(`   ✏️  In ${path.basename(filePath)}, replaced '${oldSelectorValue}' with '${newSelectorValue}'`);
            changed = true;
        }
    }

    if (changed) {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`✅ Updated: ${path.basename(filePath)}`);
    }
    return changed;
}


// --- Script Execution ---

async function runAutoRefactor() {
    console.log('\n🔄 Starting context-aware auto-refactor...');

    // Use command-line argument for mapping path, or default.
    const MAPPING_PATH = process.argv[2] || 'selector-mapping.json';

    if (!fs.existsSync(MAPPING_PATH)) {
        console.error(`❌ ERROR: Mapping file not found at ${MAPPING_PATH}`);
        process.exit(1);
    }

    const mappingData = JSON.parse(fs.readFileSync(MAPPING_PATH, 'utf8'));
    // Correctly read the `mappings` key from the JSON file generated by compare-selectors.js
    const pageMappings = mappingData.mappings;

    if (!pageMappings || Object.keys(pageMappings).length === 0) {
        console.log('✅ No selector mappings to apply. Exiting.');
        return;
    }

    const allTestFiles = TEST_FILE_DIRS.flatMap(dir => getAllFiles(path.join(__dirname, dir)));

    // --- New Simplified Logic ---
    // Flatten all page mappings into a single mapping object.
    // This is a simpler, more robust approach than trying to match files to pages.
    const allMappings = {};
    for (const pagePath in pageMappings) {
        Object.assign(allMappings, pageMappings[pagePath]);
    }

    // Create a new mapping containing only the selectors that have actually changed.
    const changedMappings = {};
    for (const oldSelector in allMappings) {
        const newSelector = allMappings[oldSelector];
        // A selector is considered changed if the new selector is different, or if it was removed (null).
        if (oldSelector !== newSelector) {
            changedMappings[oldSelector] = newSelector;
        }
    }

    if (Object.keys(changedMappings).length === 0) {
        console.log('✅ No selector changes to apply. Exiting.');
        return;
    }

    console.log(`\n🔎 Applying ${Object.keys(changedMappings).length} selector change(s) across all relevant test files...`);

    let totalFilesChanged = 0;
    allTestFiles.forEach(file => {
        if (refactorFile(file, changedMappings)) {
            totalFilesChanged++;
        }
    });

    if (totalFilesChanged > 0) {
        console.log(`\n✅ Successfully refactored ${totalFilesChanged} file(s).`);
    } else {
        console.log(`\n✅ No files required changes.`);
    }

    console.log('\n🎉 Auto-refactor complete!');
}

runAutoRefactor();
